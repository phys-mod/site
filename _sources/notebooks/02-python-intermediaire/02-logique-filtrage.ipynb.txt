{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Logique, structures de contrôle et filtrage"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Opérateurs de comparaison\n",
    "\n",
    "Une **expression booléenne** est une expression qui est soit vraie, soit fausse. Par exemple, l'opérateur `==` compare les expressions de chaque côté de l'opérateur et renvoie la valeur `True` (vrai) s'ils sont égaux et `False` (faux) sinon."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Opérateur égalité\n",
    "print(5 == 5)\n",
    "print(2 == 4)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Les valeurs `True` et `False` appartiennent au type `bool` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "print(type(True))\n",
    "print(type(False))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La liste des opérateurs de comparaison est la suivante:\n",
    "\n",
    "| opérateur | description\n",
    "|--|--\n",
    "| `x == y`  | x est égal à y\n",
    "| `x != y` | x n'est pas égal à y\n",
    "| `x > y`  | x est strictement supérieur à y\n",
    "| `x < y`  | x est strictement inférieur à y\n",
    "| `x >= y` | x est supérieur ou égal à y\n",
    "| `x <= y` | x est inférieur ou égal à y"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Attention**\n",
    "\n",
    "Ces opérateurs semblent familiers. Cependant, les symboles de Python sont différents des symboles mathématiques. En particulier, le signe = des mathématiques n'est pas le symbole `=` de Python, qui est l'opérateur d'affectation, alors que le symbole `==` est un opérateur relationnel en Python.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Égalité\n",
    "\n",
    "Pour vérifier l'égalité entre 2 expressions on utilise le symbole `==`. Les expressions de chaque côté de l'opérateur sont évaluées et comparées. Pour vérifier que 2 expressions ne sont pas égales on utilise l'opérateur `!=`.\n",
    "\n",
    "Les exemples suivants renvoient tous le booléen `True` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "print((7 + 2) == 9)\n",
    "print(\"bonjour\" != \"au revoir\")\n",
    "print(True == True)\n",
    "print(3 * 5 == 5. + 5. + 5.)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "D'après vous, quels sont les résultats des comparaisons suivantes. Vérifiez dans la console :\n",
    "\n",
    "1. `True` est *égal* à `False`\n",
    "2. `43` n'est *pas égal* à `3 * 15`\n",
    "3. `\"Paris\"` est *égal* à `\"paris\"`\n",
    "4. `True` est *égal* à `\"Paris\"`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "print(True == False)\n",
    "print(43 != (3 * 15))\n",
    "print(\"Paris\" == \"paris\")\n",
    "print(True == \"Paris\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Supérieur et inférieur\n",
    "\n",
    "On peut utiliser les opérateurs de comparaison *inférieur à* `<` et *supérieur à* `>`. On peut aussi les combiner au symbole `=` pour former les opérateurs *inférieur ou égal* `<=` et *supérieur ou égal* `>=`. Le signe égal est toujours après le chevron (la flèche *inférieur à* ou la flèche *supérieur à*).\n",
    "\n",
    "Voici quelques exemples qui renvoient tous le booléen `True` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "print(6 < 23)\n",
    "print(8 - 3 >= 5)\n",
    "print(\"beta\" < \"theta\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Comme on l'a vu précédemment, pour une valeur de type `string` (chaîne de charactères), l'ordre croissant est l'ordre alphabétique."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "D'après vous, quels sont les résultats des comparaisons suivantes. Vérifiez dans la console :\n",
    "\n",
    "1. `10 / 3` est *supérieur* à `3.33333`\n",
    "2. `\"chateau\"` est *supérieur ou égal* à `\"chien\"`\n",
    "3. `True` est *supérieur* à `False`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "print(10 / 3 > 3.33333)\n",
    "print(\"chateau\" >= \"chien\")\n",
    "print(True > False)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Comparer des tableaux\n",
    "\n",
    "Il est possible d'utiliser les opérateurs de comparaison directement avec des tableaux Numpy. Les comparaisons sont effectuées pour chaque élément du tableau. Le résultat est un tableau Numpy contenant les résultats de chacune des comparaisons, c'est-à-dire un tableau de valeurs de type booléen.\n",
    "\n",
    "Par exemple :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Importer le module Numpy\n",
    "import numpy as np\n",
    "\n",
    "# Créer des tableaux Numpy\n",
    "A = np.array([1.4,  7.1, 9.0, 2.5, -4.6])\n",
    "B = np.array([2.6, -5.7, 4.0, 2.5,  5.8])\n",
    "\n",
    "# Comparaisons\n",
    "print(A > 5.)\n",
    "print(B > A)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Vérifions que le résultat de la comparaison entre des tableaux Numpy est bien un tableau Numpy contenant des booléens :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Comparaison entre 2 tableaux Numpy A et B\n",
    "C = B > A\n",
    "\n",
    "# Type du résultat : tableau Numpy\n",
    "print(type(C))\n",
    "\n",
    "# Type des éléments du tableau : booléens\n",
    "print(C.dtype)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "Les tableaux Numpy suivants contiennent les surfaces (en $\\mathrm{m}^2$) des pièces de 2 maisons différentes, A et B, dans le même ordre : une chambre, le salon, la cuisine et la salle de bain :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "maison_A = np.array([15.5, 22.3, 6.6, 8.5])  # m**2\n",
    "maison_B = np.array([12.3, 28.8, 12.7, 8.0]) # m**2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En utilisant des opérateurs de comparaison, déterminer :\n",
    "\n",
    "1. quelles sont les pièces de la maison A dont la superficie est supérieure ou égal à 10.0 $\\mathrm{m}^2$ ?\n",
    "2. quelles sont les pièces de la maison B dont les surfaces sont plus grandes que celles de la maison A ?\n",
    "3. la surface totale de la maison A est-elle plus grande que celle de la maison B ? Note : on pourra utiliser l'opérateur Numpy `sum()`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 1 : Chambre, salon et cuisine\n",
    "print(maison_A >= 10.0)\n",
    "\n",
    "# 2 : Salon et cuisine\n",
    "print(maison_B > maison_A)\n",
    "\n",
    "# 3 : Non\n",
    "print(np.sum(maison_A) > np.sum(maison_B))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Opérateurs logiques\n",
    "Il existe trois opérateurs logiques : `and`, `or` et `not`. Il ont le même sens que leur traduction, respectivement : *et*, *ou* et *non*. On peut les utiliser pour combiner des expressions booléennes. Par exemple, l'expression `x > 10 and x <= 14` est vraie seulement si `x` est strictement supérieur à `10` **et** `x` est inférieur ou égal à `14`.\n",
    "\n",
    "L'expression `n % 5 == 0 or n % 6 == 0` est vraie si `n` est divisible par `5` **ou** si `n` est divisible par `6`.\n",
    "\n",
    "Finalement, l'opérateur `not` *nie* une expression. Par exemple `not x > y` est vraie si `x > y` est faux, c'est-à-dire si `x` est inférieur ou égal à `y`."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "Créons les variables `masse_terre` et `masse_mars` contenant les masses de la Terre et de Mars en kg :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "masse_terre = 5.9736e24 # kg\n",
    "masse_mars  = 6.4185e23 # kg"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "En utilisant des opérateurs logiques et des expressions booléennes, déterminer :\n",
    "\n",
    "1. si la masse de la Terre est strictement comprise entre $10^{23}$ et $10^{24}$ kg\n",
    "2. si la masse de Mars est supérieure ou égale à $10^{25}$ kg *ou* si elle est inférieure ou égale à la masse de la Terre\n",
    "3. si la masse de la Terre est strictement comprise entre 1 et 10 fois la masse de Mars\n",
    "\n",
    "Finalement, déterminer sans l'écrire *a priori* le résultat de l'expression `not(not(masse_terre > 1e23) or not(masse_terre >= masse_mars and masse_mars > 1e25))`"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 1: faux\n",
    "print(1e23 < masse_terre and masse_terre < 1e24)\n",
    "\n",
    "# 2: vrai\n",
    "print(1e25 <= masse_mars or masse_mars <= masse_terre)\n",
    "\n",
    "# 3: vrai\n",
    "print(masse_mars < masse_terre and masse_terre < 10 * masse_mars)\n",
    "\n",
    "# 4: faux\n",
    "print(not(not(masse_terre > 1e23) or not(masse_terre >= masse_mars and masse_mars > 1e25)))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Numpy et les opérateurs logiques\n",
    "Les opérateurs logiques `and`, `or` et `not` ne fonctionnent pas avec les tableaux Numpy. Nous avons vu que le résultat de la comparaison de 2 tableaux Numpy est un tableau Numpy contenant des booléens. Pour effectuer des opérations logiques entre les éléments de 2 tableaux Numpy `bool_1` et `bool_2` contenant des booléens, il faut utiliser les fonctions Numpy suivantes :\n",
    "\n",
    "| fonction Numpy | opérateur logique |\n",
    "|--|--\n",
    "| `logical_and(bool_1, bool_2)` | et\n",
    "| `logical_or(bool_1, bool_2)` | ou\n",
    "| `logical_not(bool_1, bool_2)` | non\n",
    "\n",
    "`bool_1` et `bool_2` peuvent être le résultat d'une comparaison entre des tableaux Numpy. Reprenons les tableaux `A` et `B` créés plus haut :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Créer des tableaux Numpy\n",
    "A = np.array([1.4,  7.1, 9.0, 2.5, -4.6])\n",
    "B = np.array([2.6, -5.7, 4.0, 2.5,  5.8])\n",
    "\n",
    "# Création des tableaux de booléens, résultats de comparaisons\n",
    "# Ici on cherche tous les éléments de A qui sont strictement inférieurs à ceux de B et à 5.0\n",
    "bool_1 = A < B\n",
    "bool_2 = A < 5.0\n",
    "\n",
    "# Opération logique sur les tableaux de booléens\n",
    "print(np.logical_and(bool_1, bool_2))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On voit que seuls les premier et dernier éléments de A sont à la fois strictement inférieurs à ceux de B et à 5.0.\n",
    "\n",
    "Il existe de nombreuses fonctions logiques dans le module Numpy, [la liste est disponible](https://numpy.org/doc/stable/reference/routines.logic.html) sur le site du module. Parmi les fonctions utiles, on note :\n",
    "\n",
    "- `all()` : test si tous les éléments d'un tableau sont vrais\n",
    "- `any()` : test si au moins un des éléments d'un tableau est vrai\n",
    "\n",
    "Par exemple :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# test si au moins un des éléments de A est strictement supérieur à 8 :\n",
    "print( np.any(A > 8.0) )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "Reprenons les tableaux `A`et `B` définis plus haut, contenant les surfaces en $\\mathrm{m}^2$ des pièces de 2 maisons :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Superficie des pièces : chambre, salon, cuisine, salle de bain\n",
    "maison_A = np.array([15.5, 22.3, 6.6, 8.5])  # m**2\n",
    "maison_B = np.array([12.3, 28.8, 12.7, 8.0]) # m**2"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Déterminer, grâce aux fonctions logiques de Numpy :\n",
    "\n",
    "1. quelles sont les pièces de la maison A dont la surface est strictement comprise entre 8 et 16 $\\mathrm{m}^2$ ?\n",
    "2. quelles sont les pièces dont la surface n'est pas strictement inférieure à 10 dans les 2 maisons A et B ?\n",
    "3. est-ce qu'au moins une des pièces de la maison A est plus grande que les pièces correspondantes de la maison B ?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 1 : Chambre et salle de bains\n",
    "bool_1 = maison_A > 8\n",
    "bool_2 = maison_A < 16\n",
    "print(np.logical_and(bool_1, bool_2))\n",
    "\n",
    "# 2 : Chambre et salon\n",
    "bool_1 = np.logical_not(maison_A < 10)\n",
    "bool_2 = np.logical_not(maison_B < 10)\n",
    "print(np.logical_and(bool_1, bool_2))\n",
    "\n",
    "# 3 : Oui\n",
    "print(any(A > B))"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Instructions conditionnelles\n",
    "Il est très fréquent dans un programme que l'on veuille exécuter une instruction seulement si certaines conditions sont remplies. Pour cela, on utilise l'instruction `if` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Création et affectation de la variable x\n",
    "x = 2\n",
    "\n",
    "# Test si x est positif\n",
    "if x > 0:\n",
    "    print(\"x est strictement positif\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "L'expression booléenne après l'instruction `if` est appelée **condition**. \n",
    "\n",
    "Dans le code ci-dessus, vérifiez ce qu'il se passe si vous changez la valeur de la variable `x` pour une valeur négative."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-info\">\n",
    "\n",
    "**Instructions composées**\n",
    "\n",
    "Les instructions `if`, comme d'autres que nous verrons par la suite, sont des *instructions composées* : un *en-tête*, suivi d'un corps *indenté* contenant une instruction par ligne. Il n'y a pas de limite au nombre d'instructions contenues dans le corps indenté, mais il doit y en avoir *au moins une*.\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Si la condition après l'instruction `if` n'est pas vérifiée, il est possible d'exécuter une **instruction alternative** avec l'instruction `else` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Ré-affectation de la variable x\n",
    "x = 3\n",
    "\n",
    "# Test si x est pair ou impair\n",
    "if x % 2 == 0:\n",
    "    print(\"x est pair\")\n",
    "else:\n",
    "    print(\"x est impair\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "La condition est soit vraie soit fausse, une des 2 instructions est donc forcément exécutée. Ces 2 alternatives sont appelées des **branchements**.\n",
    "\n",
    "Il est possible d'avoir besoin de plus de 2 branches. On écrit alors un **enchaînement de conditions** avec l'instruction `elif` :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Ré-affectation de la variable x\n",
    "x = 0\n",
    "\n",
    "# Test si x positif, négatif ou nul\n",
    "if x > 0:\n",
    "    print(\"x est positif\")\n",
    "elif x < 0:\n",
    "    print(\"x est négatif\")\n",
    "else:\n",
    "    print(\"x est nul\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Il n'y a pas de limite au nombre de conditions qui peuvent être enchaînées, c'est-à-dire que l'on peut mettre autant d'instructions `elif` que l'on veut. L'instruction `else` sera toujours à la fin. Même si plusieurs des conditions sont vérifiées, seulement la première qui est vérifiée sera exécutée. Par exemple :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "bouton_1 = False\n",
    "bouton_2 = True\n",
    "\n",
    "if bouton_1 and bouton_2:\n",
    "    print(\"Les 2 boutons sont allumés\")\n",
    "elif bouton_1:\n",
    "    print(\"Le bouton 1 est allumé\")\n",
    "elif bouton_2:\n",
    "    print(\"Le bouton 2 est allumé\")\n",
    "elif bouton_1 or bouton_2:\n",
    "    print(\"Un des 2 boutons est allumé\")\n",
    "else:\n",
    "    print(\"Aucun des 2 boutons n'est allumé\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Dans l'exemple ci-dessus, l'instruction correspondant à la condition `bouton_1 or bouton_2` ne sera jamais exécutée, car si elle est vraie alors il y aura forcément une des 2 conditions `bouton_1` ou `bouton_2` qui est vraie et dont l'instruction  sera exécutée plus tôt."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "Écrire l'instruction conditionnelle avec les branchements suivant :\n",
    "\n",
    "1. si `x` est un multiple de 5 et de 6 afficher à l'écran \"x est un multiple de 5 et de 6\"\n",
    "2. si `x` est un multiple de 5 et pas de 6 afficher à l'écran \"x est un multiple de 5 mais pas de 6\"\n",
    "3. si `x` est un multiple de 6 et pas de 5 afficher à l'écran \"x est un multiple de 6 mais pas de 5\"\n",
    "4. si `x` n'est un multiple ni de 5 ni de 6 afficher à l'écran \"x n'est un multiple ni de 5 ni de 6\"\n",
    "\n",
    "Testez vos conditions avec les chiffres 8, 10, 12, et 30."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# Création et affectation de la variable x\n",
    "x = 30\n",
    "\n",
    "# Instruction conditionnelle\n",
    "if x % 5 == 0 and x % 6 == 0:\n",
    "    print(\"x est un multiple de 5 et de 6\")\n",
    "elif x % 5 == 0 and x % 6 != 0:\n",
    "    print(\"x est un multiple de 5 mais pas de 6\")\n",
    "elif x % 5 != 0 and x % 6 == 0:\n",
    "    print(\"x est un multiple de 6 mais pas de 5\")\n",
    "else:\n",
    "    print(\"x est un multiple ni de 5 ni de 6\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Filtrer un tableau Numpy\n",
    "Pour extraire un sous-tableau Numpy qui vérifie certaines conditions, il est possible d'utiliser un tableau de booléens en indice d'un autre tableau :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Créer des tableaux Numpy\n",
    "A = np.array([1.4,  7.1, 9.0, 2.5, -4.6])\n",
    "B = np.array([2.6, -5.7, 4.0, 2.5,  5.8])\n",
    "\n",
    "# cond est un tableau Numpy de booléens\n",
    "cond = A > 4\n",
    "print(cond)\n",
    "\n",
    "# Filtrer le tableau A avec le tableau cond\n",
    "print(A[cond])\n",
    "\n",
    "# Il est possible de filtrer le tableau B avec la condition sur A\n",
    "print(B[cond])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On voit que les éléments filtrés sont ceux qui correspondent aux valeurs `True` du tableau `cond`. On peut filtrer les 2 tableaux sans créer le tableau `cond` intermédiaire :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "print( A[A > 4] )\n",
    "print( B[A > 4] )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finalement, on peut utiliser les fonctions logiques de Numpy pour combiner les conditions :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "cond = np.logical_and(A > 0, A < 5)\n",
    "print( A[cond] )"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "\n",
    "1. Extraire du tableau `A` toutes les valeurs négatives\n",
    "2. Extraire du tableau `B` toutes les valeurs strictement comprises entre 1 et 3"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 1.\n",
    "print(A[A < 0])\n",
    "\n",
    "# 2.\n",
    "print(B[np.logical_and(B > 1, B < 3)])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Filtrer un DataFrame\n",
    "Filtrer un objet DataFrame fonctionne de façon similaire au filtrage d'un tableau Numpy. Pour cela il faut extraire un objet Series de l'objet DataFrame, et lui appliquer une condition. On obtient alors un objet Series contenant des booléens, avec lequel on peut filtrer l'objet DataFrame.\n",
    "\n",
    "Reprenons la liste des pays de l'union européenne sauvée dans le module précédent :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Import du module pandas\n",
    "import pandas as pd\n",
    "\n",
    "# Lecture du fichier pickle contenant les données\n",
    "df_europe = pd.read_pickle('europe.pkl')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Nous voulons extraire la liste des pays contenant plus de 50 millions d'habitants :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": []
   },
   "outputs": [],
   "source": [
    "# Afficher les noms des colonnes\n",
    "print(df_europe.columns)\n",
    "\n",
    "# On extrait l'objet Series correspondant à la colonne 'population'\n",
    "sr_population = df_europe['population']\n",
    "\n",
    "# On applique la condition sur le nombre d'habitants\n",
    "cond = sr_population > 50e6\n",
    "\n",
    "# Afficher l'objet cond\n",
    "cond.head(n = 2)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "On voit que la variable `cond` est un objet de type Series qui contient des booléens."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# on filtre l'objet df_europe avec l'objet cond\n",
    "df_europe_big = df_europe[cond]\n",
    "\n",
    "# on affiche le tableau filtré\n",
    "df_europe_big"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "De façon beaucoup plus synthétique on aurait pu se passer de l'objet intermédiaire `cond` en écrivant :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_europe[ df_europe['population'] > 50e6 ]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "De la même manière que pour les tableaux Numpy, il est possible d'utiliser [les fonctions logiques de Numpy](https://numpy.org/doc/stable/reference/routines.logic.html) sur les objets Series. Par exemple, cherchons les pays dont la date d'adhésion est supérieure à 1990 *et* dont la population est supérieure à 10 millions :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# conditions\n",
    "cond1 = df_europe[\"population\"] > 10e6\n",
    "cond2 = df_europe[\"date d'adhésion\"] > np.datetime64('1990','Y')\n",
    "\n",
    "# operation logique et\n",
    "df_europe[np.logical_and(cond1, cond2)]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Le module Pandas a introduit une notation un peu plus pratique pour les opérations logiques :\n",
    "\n",
    "| Opération | notation Pandas\n",
    "|--|--\n",
    "| et | `&`\n",
    "| ou | `\\|`\n",
    "| non | `~`\n",
    "\n",
    "Par exemple, cherchons les pays dont l'année d'adhésion n'est pas 1957 et dont le nombre de sièges est supérieur à 50 :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "df_europe[ ~(df_europe[\"date d'adhésion\"] == np.datetime64('1957','Y')) & (df_europe[\"sièges\"] > 50) ]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "<div class=\"alert alert-warning\">\n",
    "\n",
    "**Attention**\n",
    "\n",
    "Ces opérateurs de logique binaire (`&`, `\\|`, `~`) n'ont pas la même priorité des opérations que les opérateurs de logique booléenne (`and`, `or`, `not`), et en l'occurence ils sont prioritaires devant les opérateurs de comparaison (`==`, `<`, `>`, `<=`, `>=`, `!=`), contrairement aux opérateurs de logique booléenne, donc il est conseillé de mettre des parenthèses. La priorité des opérations peut être vérifiée [ici](https://fr.wikibooks.org/wiki/Programmation_Python/Tableau_des_op%C3%A9rateurs).\n",
    "\n",
    "Par exemple, `~(df_europe[\"date d'adhésion\"] == np.datetime64('1957','Y')) & df_europe[\"sièges\"] > 50` ne donne pas le bon résultat, parce que Python tente d'abord d'effectuer l'opération binaire `&` entre `~(df_europe[\"date d'adhésion\"] == np.datetime64('1957','Y'))` et `df_europe[\"sièges\"]` (au lieu de `df_europe[\"sièges\"] > 50`). Alors que `~(df_europe[\"date d'adhésion\"] == np.datetime64('1957','Y')) & (df_europe[\"sièges\"] > 50)` donne le résultat souhaité (regardez bien les parenthèses).\n",
    "\n",
    "</div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Exercice\n",
    "À partir du DataFrame `df_europe`, extraire :\n",
    "\n",
    "1. Les pays dont la lettre commence par une lettre entre 'c' et 'g' (non inclus). On rappelle que l'ordre croissant pour les objets de type `str` est l'ordre alphabétique.\n",
    "2. Pour les pays qui ont adhérés en 2004, ceux dont le nombre de siège est 6 ou dont le poids est inférieur à 2."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 1.\n",
    "df_europe[ (df_europe[\"pays\"] >= 'd') & (df_europe[\"pays\"] < 'g') ]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {
    "tags": [
     "solution"
    ]
   },
   "outputs": [],
   "source": [
    "# 2.\n",
    "cond1 = df_europe[\"date d'adhésion\"] == np.datetime64('2004', 'Y')\n",
    "cond2 = (df_europe[\"sièges\"] == 6) | (df_europe[\"poids\"] < 2)\n",
    "\n",
    "df_europe[ cond1 & cond2 ]"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
